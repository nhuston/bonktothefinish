document.addEventListener("DOMContentLoaded", function(e) {
	create_scatter_plot("#graph_5K",races["5K"]);
});

var races = <%= processed_races_info().to_json %>;
console.log(races);

/*
D3 examples adapted from
https://bl.ocks.org/d3noob/6f082f0e3b820b6bf68b78f2f7786084
*/

// Set the dimensions of the canvas / graph
var margin = {
        top: 30,
        right: 20,
        bottom: 30,
        left: 50
    },
    width = 600 - margin.left - margin.right,
    height = 270 - margin.top - margin.bottom;

// set the dimensions and margins of the graph
var margin = {
        top: 20,
        right: 20,
        bottom: 30,
        left: 50
    },
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

// parse the date / time
var parseDate = d3.timeParse("%Y-%m-%d");

// preprocess/format the data
for(race_name in races){
	for(race of races[race_name]){
		race.date = parseDate(race.date);
		race.time = (race.time);
	}
	races[race_name].sort(function(a,b){
		return a.date - b.date;
	});
}

//d3 only has date formatters for time, not durations. So must write own linear axis formatter
function format_duration(d) {
    var hours = Math.floor(d / 3600),
        minutes = Math.floor((d - (hours * 3600)) / 60),
        seconds = d - (minutes * 60);
    var output = seconds + 's';
    if (minutes) {
        output = minutes + 'm ' + output;
    }
    if (hours) {
        output = hours + 'h ' + output;
    }
    return output;
}

function get_race_point_class(data){
	return function(d){
		var classes=""
		var min_time = d3.min(data, function(d){return d.time;});
		var max_time = d3.max(data, function(d){return d.time;});
		if(d.trail){
			classes += " trail ";
		}else{
			classes += " no_trail ";
		}

		if(d.time === min_time){
			classes += " min_time ";
		}
		if(d.time === max_time){
			classes += " max_time ";
		}
		return classes;
	};
}

function create_scatter_plot(DOM_id, data){
	// append the svg obgect to the body of the page
	// appends a 'group' element to 'svg'
	// moves the 'group' element to the top left margin
	var svg = d3.select(DOM_id).append("svg")
		.attr("width", width + margin.left + margin.right)
		.attr("height", height + margin.top + margin.bottom)
    .attr('viewBox','0 0 '+(width + margin.left + margin.right)+' '+(height + margin.top + margin.bottom)) //make responsive
    .attr('preserveAspectRatio','xMinYMin') //make responsive
		.append("g")
		.attr("transform",
			"translate(" + margin.left + "," + margin.top + ")");

	var get_x = function(d){ return d.date;}
	var get_y = function(d){ return d.time;}

	// set the ranges
	var x = d3.scaleTime()
		.range([0, width])
		.domain(d3.extent(data, get_x));
	var y = d3.scaleLinear()
		.range([height, 0])
		.domain(d3.extent(data, get_y));

	var get_axis_x = function(d){ return x(get_x(d));}
	var get_axis_y = function(d){ return y(get_y(d));}

	// define the line
	var valueline = d3.line()
		.x(get_axis_x)
		.y(get_axis_y);

	// Add the valueline path.
	svg.append("path")
	.data([data])
	.attr("class", "line")
	.attr("d", valueline);

	// Add the scatterplot
	svg.selectAll("dot")
	.data(data)
	.enter().append("circle")
	.attr("r", 5)
	.attr("cx", get_axis_x)
	.attr("cy", get_axis_y)
	.attr("class",get_race_point_class(data));

	// Add the X Axis
	svg.append("g")
	.attr("transform", "translate(0," + height + ")")
	.call(d3.axisBottom(x));

	// Add the Y Axis
	svg.append("g")
	.call(
		d3.axisLeft(y)
		.tickFormat(format_duration)
	);
}
